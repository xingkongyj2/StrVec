#include "StrVec.h"//static变量一定要在cpp中定义，.h中只是声明std::allocator<std::string> StrVec::alloc;//分配元素StrVec::StrVec():elements(nullptr),first_free(nullptr),cap(nullptr){};size_t StrVec::size() const{    return first_free-elements;}size_t StrVec::capacity() const{    return cap-elements;}std::string *StrVec::begin() const{    return elements;}std::string *StrVec::end() const{    return first_free;}void StrVec::chk_n_alloc(){    if(size()==capacity()) reallocate();}void StrVec::push_back(const std::string &s){    chk_n_alloc();    //在first_free指向的元素中构造s的副本    alloc.construct(first_free++,s);}std::pair<std::string*, std::string*>StrVec::alloca_n_copy(const std::string *b, const std::string *e){    auto data=alloc.allocate(e-b);    return {data,std::uninitialized_copy(b,e,data)};}void StrVec::free(){    if(elements){        for (auto p = first_free; p !=elements ; )        {            alloc.destroy(--p);            alloc.deallocate(elements,cap-elements);        }    }}StrVec::StrVec(const StrVec &s){    auto newdata=alloca_n_copy(s.begin(),s.end());    elements=newdata.first;    first_free=cap=newdata.second;}StrVec::~StrVec(){    free();}StrVec& StrVec::operator=(const StrVec &rhs){    auto data=alloca_n_copy(rhs.begin(),rhs.end());    free();    elements=data.first;    first_free=cap=data.second;    return *this;}void StrVec::reallocate(){    auto newcapacity=size()?2*size():1;    auto newdata=alloc.allocate(newcapacity);    auto dest=newdata;    auto elem=elements;    for (size_t i=0;i!=size();++i)        alloc.construct(dest++,std::move(*elem++));    free();    elements=newdata;    first_free=dest;    cap=elements+newcapacity;}